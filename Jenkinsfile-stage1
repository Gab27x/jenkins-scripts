pipeline {
    agent any

    tools {
        maven 'Maven'
        jdk 'Java11'
    }

    environment {
        GIT_REPO = 'https://github.com/Gab27x/ecommerce-microservice-backend-app.git'
        BRANCH = 'master'
        INIT_SLEEP_TIME = 20
        SLEEP_TIME = 15
        MAX_RETRIES = 10
        NODES_NUM = 5
        EUREKA_URL = 'http://service-discovery-container:8761/eureka/apps' 
        DOCKER_REPO = 'gab27x/microservices'
        SERVICES = 'user-service,order-service'
    
    }

    stages {

        stage('CLONE') {
            steps {
                deleteDir()
                sh "git clone -b ${BRANCH} ${GIT_REPO} ."
            }
        }

        stage('BUILD AND TEST') {
            steps {
                sh "mvn clean package"
                sh "mvn test"
            }
        }

        stage('DOCKER COMPOSE UP'){
            steps{
                echo '=== Turning on core ==='
                sh 'docker compose -f core.yml up -d'
                echo 'core up'

                echo '=== Turning on project-compose ==='
                sh 'docker compose -f project-compose.yml up -d --build'
                echo 'micro services up'
 
            }
        }

        stage('TEST HEALTH') {
            steps {
                script {
                    def maxRetries = env.MAX_RETRIES.toInteger()
                    def sleepTime = env.SLEEP_TIME.toInteger()
                    def nodesNum = env.NODES_NUM.toInteger()
                    def eurekaUrl = env.EUREKA_URL
                    def success = false

                    for (int i = 1; i <= maxRetries; i++) {
                        echo "Intento ${i} de ${maxRetries}..."
                        
                        def response = sh(
                            script: "docker run --rm --network microservices_network curlimages/curl -s --max-time 5 ${eurekaUrl} || true",
                            returnStdout: true
                        ).trim()

                        if (response) {
                            def appCount = sh(script: "echo '${response}' | grep -o '<application>' | wc -l | tr -d ' '", returnStdout: true).trim().toInteger()
                            def upCount = sh(script: "echo '${response}' | grep -c '<status>UP</status>' | tr -d ' '", returnStdout: true).trim().toInteger()
                            echo "Aplicaciones registradas: ${appCount}, UP: ${upCount}"

                            if (appCount == nodesNum && upCount == nodesNum) {
                                success = true
                                break
                            }
                        } else {
                            echo "No se obtuvo respuesta de Eureka."
                        }

                        sleep sleepTime
                    }

                    if (!success) {
                        error "Eureka no alcanzó las ${nodesNum} aplicaciones UP tras ${maxRetries} intentos."
                    } else {
                        echo "Eureka está completamente operativo."
                    }
                }
            }
        }

        stage('POSTMAN TESTS') {
            steps {
                echo '=== Ejecutando pruebas Postman ==='
                sh '''
                    docker run --rm \
                    --name postman-newman-runner \
                    --network microservices_network \
                    -v $(pwd):/etc/newman \
                    postman/newman:latest run /etc/newman/postman_collection.json \
                    --environment /etc/newman/variables_pipeline.json \
                    --reporters cli,junit \
                    --reporter-junit-export /etc/newman/newman-report.xml
                '''
            }
        }

        stage('SHUTDOWN DOCKER COMPOSE'){
            steps{

                sh'docker compose -f project-compose.yml down -v --remove-orphans'
            }
        }

        stage('Build & Push Docker Images') {
            steps {
                script {
                    // Login a Docker Hub usando credenciales de Jenkins
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin'
                    }

                    // Convertir string de servicios a lista
                    def servicesList = SERVICES.split(',')

                    servicesList.each { service ->
                        // Etiqueta para el "último"
                        def LATEST_TAG = "${service}-latest" 
                        
                        echo "============================="
                        echo "Processing $service"
                        echo "============================="

                        // --- LÓGICA DE EXTRACCIÓN Y CÁLCULO CORREGIDA ---
                        def lastTagFull = sh(
                            script: """
                                curl -s "https://hub.docker.com/v2/repositories/$DOCKER_REPO/tags?page_size=100" \
                                | jq -r '.results[].name' \
                                | grep "^${service}-[0-9]*\$" \
                                | sort -V \
                                | tail -1
                            """,
                            returnStdout: true
                        ).trim()

                        def lastTagNumber = "0"
                        if (lastTagFull) {
                            // Extrae solo la parte numérica después del guion
                            def matcher = (lastTagFull =~ /${service}-(\d+)/)
                            if (matcher.find()) {
                                lastTagNumber = matcher.group(1)
                            }
                        }

                        // Calcula nueva versión. Si no se encuentra nada, empieza en 1.
                        def newTagNumber = lastTagNumber.toInteger() + 1
                        def versionTag = "${service}-${newTagNumber}" // Etiqueta de versión específica
                        
                        echo "Nueva versión para $service: $versionTag"
                        echo "Etiqueta 'Latest' a aplicar: $LATEST_TAG"

                        // Build del jar con Maven
                        sh """
                            cd $service
                            ./mvnw clean package -DskipTests
                            cd ..
                        """

                        // Build, Etiquetado Doble y Push de la imagen Docker
                        sh """
                            # 1. Build con la etiqueta de versión (e.g., user-service-2)
                            docker build -t $DOCKER_REPO:$versionTag $service

                            # 2. Etiquetar la misma imagen con la etiqueta 'latest' 
                            docker tag $DOCKER_REPO:$versionTag $DOCKER_REPO:$LATEST_TAG

                            # 3. Push de ambas etiquetas al Docker Hub
                            docker push $DOCKER_REPO:$versionTag
                            docker push $DOCKER_REPO:$LATEST_TAG
                        """
                    }
                }
            }
        }

        stage('Minikube Setup & Deployment') {
            steps { // <-- INICIO DEL BLOQUE 'steps' de la etapa Minikube
           script {
            echo "============================="
            echo "Starting Minikube & Deploying Microservices"
            echo "============================="

            // 1. Iniciar Minikube
            echo "Starting Minikube..."
            sh "minikube start --cpus 4 --memory 8192"

            // 2. Despliegue de Helm
            echo "Deploying microservices via Helm..."
            sh "helm install microservices ./microservices -n stage --create-namespace -f ./microservices/values-prod.yaml"

            // 3. Espera a que los pods estén listos
            echo "Waiting for pods to be ready..."
            sh '''
                kubectl wait --for=condition=available deployment --all -n stage --timeout=300s || true
                kubectl get pods -n stage
            '''
        }
            } // <-- FIN DEL BLOQUE 'steps' de la etapa Minikube
        } // <-- FIN DE LA ETAPA 'Minikube Setup & Deployment'


            stage('Show relase notes'){

            steps{
                sh "helm get notes microservices -n stage"

                 echo '=== API Tests Job Logs ==='
            sh '''
                kubectl logs -n stage $(
                    kubectl get pods -n stage \
                    -l job-name=$(
                        kubectl get jobs -n stage -o jsonpath='{.items[*].metadata.name}' | tr ' ' '\\n' | grep microservices-api-tests | head -n1
                    ) \
                    -o jsonpath='{.items[0].metadata.name}'
                )
            '''
            }
        }



    }



    post {
        always {
            echo '=== Limpiando entorno ==='
            
            // Detener y limpiar todos los contenedores
            sh '''
                echo "== Deteniendo y removiendo contenedores Docker =="
                docker compose -f project-compose.yml down -v --remove-orphans || true
                docker compose -f core.yml down -v --remove-orphans || true
            '''

            // --- LIMPIEZA DE MINIKUBE ---
            echo "Limpiando el clúster Minikube..."
            sh "minikube delete"
            
            // Limpiar el workspace de Jenkins
            cleanWs()
            echo '=== Workspace limpiado ==='
        }

        success {
            echo 'Pipeline completado con éxito.'

        }

        failure {
            echo 'El pipeline falló. Revisa los logs para más detalles.'
        }
    }

}
